<!DOCTYPE html>

<html>
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="../js/three.min.js"></script>
		<!--script src="js/CSG.js"></script-->
		<script src="../js/OrbitControls.js"></script>
		<link rel="stylesheet" href="../css/viu.css">
	</head>
	
	<body>
		<script type="module">
            import CSG from '../js/three-csg.js';
			// construct and setup the scene
			
			var renderer = new THREE.WebGLRenderer( {antialias:true} );
				renderer.setAnimationLoop( animate );
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.VSMShadowMap//PCFSoftShadowMap; 
				document.body.appendChild( renderer.domElement );

			var scene = new THREE.Scene();
				scene.background = new THREE.Color( 'black' );

			var camera = new THREE.PerspectiveCamera( 60, 1, 1, 1000 );
				camera.position.set( 40, 80, 40 );
				camera.lookAt( scene.position );
			
			var light = new THREE.SpotLight( 'white', 1.3 );
				light.position.set( 80*10, 50*10, 40*10 );
				light.target = scene;
				light.angle = Math.PI/3/20;
				light.penumbra = 1/2;
				light.castShadow = true;
				light.shadow.mapSize.width = 2024/8; 
				light.shadow.mapSize.height = 2024/8; 
				light.shadow.camera.near = 900; 
				light.shadow.camera.far = 1800; 
				light.shadow.camera.left = -300; 
				light.shadow.camera.right = 300; 
				light.shadow.camera.top = -300; 
				light.shadow.camera.bottom = 300; 
				//light.shadow.bias = 0.0001; 
				light.shadow.radius = 3;

				scene.add( light );

			var light = new THREE.SpotLight( 'white', 0.3 );
				light.position.set( -80*10, 50*10, -40*10 );
				light.target = scene;
				light.angle = Math.PI/3/20;
				light.penumbra = 1/2;

				scene.add( light );


			var controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI * 0.495;
				controls.minDistance = 2;
				controls.maxDistance = 100;
				controls.enableDamping = true;
				controls.dampingFactor = 0.25;
				controls.rotateSpeed = 0.3;
				controls.panSpeed = 0.7;
				controls.screenSpacePanning = false;
				controls.target.set( 0, 0, 0 );
				controls.update();
	
	
			// manage rezie
			
			window.addEventListener( 'resize', onWindowResize, false );
			onWindowResize();
			
			function onWindowResize( event )
			{
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight, true );
			}			

			var mainFrame = new THREE.Group();
				scene.add( mainFrame );
				
			// animation loop

			function animate( time )
			{
				// slow rotation of the cube
				//scene.rotation.set( 0, time/2000, 0 );
				controls.update();
				renderer.render( scene, camera );
			}
			

			// triangle sides
			
			var A = 20;
			var B = 40;
			var C = Math.sqrt(A*A+B*B);
			var K = 3;
			var ANGLE = Math.atan2(A,B);
			
			console.assert( A <= B );

			// other parameters
			
			const FRAME_WIDTH = 5;
			const FRAME_SIZE = A+B+2*FRAME_WIDTH;
			const FRAME_HEIGHT = 4;
			const FRAME_RADIUS = 6;
			const FRAME_DENT = 2;

			const INNER_RADIUS = 3;

			const GROOVE_DENT = 1;
			const GROOVE_RADIUS = 2;
			
			const TILE_HEIGHT = 1;
			
			scene.background = new THREE.Color(0.05,0.055,0.1);
			
			// the dark blue cloth
			function createFloor( )
			{
				const size = FRAME_SIZE*30;
				
				var texture = new THREE.TextureLoader().load( '../textures/fabric.jpg' );
					texture.wrapS = THREE.RepeatWrapping;
					texture.wrapT = THREE.RepeatWrapping;
					texture.repeat.set( 20, 20 );
					texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

				var geometry = new THREE.PlaneGeometry( size, size );
				
				var material = new THREE.MeshStandardMaterial( {
						color: 'dimgray',
						roughness: 1,
						metalness: 0,
						emissive: 'cornflowerblue',
						emissiveIntensity: 0.1,
						map: texture,
						bumpMap: texture } );
						
				var mesh = new THREE.Mesh( geometry, material );
					mesh.position.y = -FRAME_HEIGHT/2;
					mesh.receiveShadow = true;
					mesh.rotation.x = -Math.PI/2;
					
				scene.add( mesh );
			}

			createFloor(  );
			

			var frameTexture = new THREE.TextureLoader().load( '../textures/concrete.jpg' );
				frameTexture.wrapS = THREE.RepeatWrapping;
				frameTexture.wrapT = THREE.RepeatWrapping;
				//frameTexture.repeat.set( 1/FRAME_SIZE, FRAME_SIZE );
				frameTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

			function clone( object, posX, posZ, rotY=0 )
			{
				object = object.clone();
				object.position.x = posX;
				object.position.z = posZ;
				object.rotation.y = THREE.Math.degToRad( rotY );

				return object;
			}
			
			function createEdge(  )
			{
				// generate main frame
				
				var base1 = new THREE.BoxGeometry( FRAME_SIZE-2*FRAME_RADIUS, FRAME_HEIGHT, FRAME_SIZE ),
					base2 = base1.clone().rotateY( THREE.Math.degToRad(90) );

				var pos = FRAME_SIZE/2-FRAME_RADIUS;
				
				var corner1 = new THREE.CylinderGeometry( FRAME_RADIUS, FRAME_RADIUS, FRAME_HEIGHT, 60 ).translate( pos, 0, pos ),
					corner2 = corner1.clone().rotateY( Math.PI/2 ),
					corner3 = corner2.clone().rotateY( Math.PI/2 ),
					corner4 = corner3.clone().rotateY( Math.PI/2 );
					
				var csg = CSG.union([base1,base2,corner1,corner2,corner3,corner4]);
//const edges = new THREE.EdgesGeometry( geometry, 80 );
//const line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0 } ) );
//scene.add( line );

				var y = FRAME_HEIGHT/2-FRAME_DENT/2;
				var base1 = new THREE.BoxGeometry( A+B-2*INNER_RADIUS, FRAME_DENT, A+B ).translate(0,y,0),
					base2 = base1.clone().rotateY( Math.PI/2 );
					
				var pos = (A+B)/2-INNER_RADIUS;
				
				var corner1 = new THREE.CylinderGeometry( INNER_RADIUS, INNER_RADIUS, FRAME_DENT, 40 ).translate(pos, y, pos),
					corner2 = corner1.clone().rotateY( Math.PI/2 ),
					corner3 = corner2.clone().rotateY( Math.PI/2 ),
					corner4 = corner3.clone().rotateY( Math.PI/2 );
				
				csg = CSG.subtract([csg,base1,base2,corner1,corner2,corner3,corner4]);
				


				var pos = (A+B)/2-A/K;

				var y = FRAME_HEIGHT/2-FRAME_DENT-GROOVE_DENT/2;
				var corner1 = new THREE.CylinderGeometry( GROOVE_RADIUS, GROOVE_RADIUS, GROOVE_DENT, 40 ).translate(pos, y, pos ),
					corner2 = corner1.clone().rotateY( Math.PI/2 ),
					corner3 = corner2.clone().rotateY( Math.PI/2 ),
					corner4 = corner3.clone().rotateY( Math.PI/2 );

				var side1 = new THREE.BoxGeometry( 2*GROOVE_RADIUS, GROOVE_DENT, 2*pos ).translate(pos, y, 0 ),
					side2 = side1.clone().rotateY( Math.PI/2 ),
					side3 = side2.clone().rotateY( Math.PI/2 ),
					side4 = side3.clone().rotateY( Math.PI/2 );
					
				var len = 2*pos/Math.cos(ANGLE);
				var groove1 = new THREE.BoxGeometry( 2*GROOVE_RADIUS, GROOVE_DENT, len ).translate( 0, 0, len/2 ).rotateY( ANGLE ).translate( -pos, y, -pos ),
					groove2 = groove1.clone().rotateY( Math.PI/2 ),
					groove3 = groove2.clone().rotateY( Math.PI/2 ),
					groove4 = groove3.clone().rotateY( Math.PI/2 );

				csg = CSG.subtract([csg,base1,base2,corner1,corner2,corner3,corner4,side1,side2,side3,side4,groove1,groove2,groove3,groove4]);

				var	geometry = CSG.BufferGeometry(csg);
/*
			
				// punch the grooves
			
				var len = 2*pos/Math.cos(ANGLE);
				var groove1 = new THREE.Mesh( new THREE.BoxGeometry( 2*GROOVE_RADIUS, GROOVE_DENT, len ) ); 
					groove1.geometry.translate( 0, 0, len/2 );
					groove1.geometry.rotateY( ANGLE );
					groove1.position.set( -pos, corner1.position.y, -pos );

				var groove2 = clone( groove1, -pos, pos, 90 );
				var groove3 = clone( groove1, pos, pos, 180 );
				var groove4 = clone( groove1, pos, -pos, 270 );
				
					
				var csg = new CSG();
					csg.subtract( [mesh, corner1, corner2, corner3, corner4, side1, side2, side3, side4, groove1, groove2, groove3, groove4] );
			
				var mesh = csg.toMesh();

*/
var colorData = [];
var uv = [];
				var pos = geometry.getAttribute( 'position' );
				var nor = geometry.getAttribute( 'normal' );
				//var uv = geometry.getAttribute( 'uv' );
				
console.log('->',pos.count);				
				for( var i=0; i<pos.count; i++ )
				{
				
					var y = pos.getY( i );
					if( nor.getY(i)>0.5 && y<0 )
						colorData.push( 0.7,0.6,0.5 );
					else
					{
						colorData.push( 1,1,1 );
					}
					
					
			//		colorData.push(Math.random(),Math.random(),Math.random());
					if( nor.getY(i)>0.5 )
						uv.push( 0.02*pos.getX(i), 0.02*pos.getZ(i) );
					else
						uv.push( 0.02*(pos.getX(i)+pos.getZ(i)), 0.02*pos.getY(i) );
					
					//if( nor.getY(i)<0.5 )
					//nor.setY( i, 2 );
				}
//				nor.needsUpdate = true;

				geometry.setAttribute( 'uv', new THREE.BufferAttribute(new Float32Array(uv),2) );
					
				geometry.setAttribute( 'color', new THREE.BufferAttribute(new Float32Array(colorData),3) );

				var material = new THREE.MeshStandardMaterial( {
						color: 'white',
						roughness: 1,
						metalness: 0,
						emissive: 'ivory',
						emissiveIntensity: 0.13,
						map: frameTexture,
						bumpMap: frameTexture,
						bumpScale: 0.15,
						//side: THREE.DoubleSide,
						vertexColors: true,
						//wireframe: true,
						} );	
						
						
				var mesh = new THREE.Mesh( geometry, material );
				mesh.castShadow = true;
				mesh.receiveShadow = true;
					
				scene.add( mesh );
			}
			
			createEdge( );

/*
			function createEdge(  )
			{
				const
					size = FRAME_SIZE,
					width = FRAME_WIDTH,
					height = FRAME_HEIGHT,
					radius = FRAME_RADIUS,
					inner_radius = INNER_RADIUS;
				
				var shape = new THREE.Shape();
					shape.moveTo( 0, size/2 );
					shape.lineTo( 0, size-radius );
					shape.quadraticCurveTo( 0, size, radius, size );
					shape.lineTo( size-radius, size );
					shape.quadraticCurveTo( size, size, size, size-radius );
					shape.lineTo( size, radius );
					shape.quadraticCurveTo( size, 0, size-radius, 0 );
					shape.lineTo( radius, 0 );
					shape.quadraticCurveTo( 0, 0, 0, radius );
					shape.lineTo( 0, size/2 );
					
				var hole = new THREE.Path();
					hole.moveTo( width, size/2 );
					hole.lineTo( width, size-inner_radius-width );
					hole.quadraticCurveTo( width, size-width, inner_radius+width, size-width );
					hole.lineTo( size-inner_radius-width, size-width );
					hole.quadraticCurveTo( size-width, size-width, size-width, size-inner_radius-width );
					hole.lineTo( size-width, inner_radius+width );
					hole.quadraticCurveTo( size-width, width, size-inner_radius-width, width );
					hole.lineTo( inner_radius+width, width );
					hole.quadraticCurveTo( width, width, width, inner_radius+width );
					hole.lineTo( width, size/2 );
					
				shape.holes = [hole];
				
				var geometry = new THREE.ExtrudeGeometry( shape, {
						steps: 1,
						depth: height,
						bevelEnabled: false });
						
				var material = new THREE.MeshStandardMaterial( {
						roughness: 0.6,
						metalness: 0.2,
						emissive: 'orange',
						emissiveIntensity: 0.3,
						map: frameTexture,
						bumpMap: frameTexture,
						bumpScale: -0.25,
						side: THREE.DoubleSide } );
						
				var mesh = new THREE.Mesh( geometry, material );
					mesh.rotation.x = -Math.PI/2;
					mesh.position.set( -size/2, 0, size/2 );
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					
				scene.add( mesh );
			}
			
			createEdge( );
			
			
			function createBase( )
			{
				const
					size = FRAME_SIZE,
					height = FRAME_BASE,
					radius  = FRAME_RADIUS;
					
				var shape = new THREE.Shape();
					shape.moveTo( radius, radius );
					shape.lineTo( radius, size-radius );
					shape.lineTo( size-radius, size-radius );
					shape.lineTo( size-radius, radius );
					
				var geometry = new THREE.ExtrudeGeometry( shape, {
						steps: 1,
						depth: 0.01,
						bevelEnabled: false });
						
				var material = new THREE.MeshStandardMaterial( {
						color: 'gray',
						roughness: 0.6,
						metalness: 0.2,
						emissive: 'orange',
						emissiveIntensity: 0.3,
						map: frameTexture,
						bumpMap: frameTexture,
						bumpScale: -0.25,
						side: THREE.DoubleSide } );
						
				var mesh = new THREE.Mesh( geometry, material );
					mesh.rotation.x = -Math.PI/2;
					mesh.position.set( -size/2, height, size/2 );
					mesh.receiveShadow = true;
					
				scene.add( mesh );
			}
			
			createBase( );


			function createGrooveEdge(  )
			{
				const
					M = FRAME_WIDTH,
					N = FRAME_WIDTH+A/K-INNER_RADIUS,
					S = FRAME_SIZE,
					H = FRAME_GROOVE,
					R = INNER_RADIUS;
				
				var shape = new THREE.Shape();
					shape.moveTo( M, M );
					shape.lineTo( M, S-M );
					shape.lineTo( S-M, S-M );
					shape.lineTo( S-M, M );
					
				var hole = new THREE.Path();
					hole.moveTo( N, S/2 );
					hole.lineTo( N, S-N-R );
					hole.quadraticCurveTo( N, S-N, N+R, S-N );
					hole.lineTo( S-N-R, S-N );
					hole.quadraticCurveTo( S-N, S-N, S-N, S-N-R );
					hole.lineTo( S-N, N+R );
					hole.quadraticCurveTo( S-N, N, S-N-R, N );
					hole.lineTo( N+R, N );
					hole.quadraticCurveTo( N, N, N, N+R );
					hole.lineTo( N, S/2 );
					
				shape.holes = [hole];
				
				var geometry = new THREE.ExtrudeGeometry( shape, {
						steps: 1,
						depth: H,
						bevelEnabled: false });
						
				var material = new THREE.MeshStandardMaterial( {
						roughness: 0.6,
						metalness: 0.2,
						emissive: 'orange',
						emissiveIntensity: 0.3,
						map: frameTexture,
						bumpMap: frameTexture,
						bumpScale: -0.25,
						side: THREE.DoubleSide } );
						
				var mesh = new THREE.Mesh( geometry, material );
					mesh.rotation.x = -Math.PI/2;
					mesh.position.set( -S/2, 0, S/2 );
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					
				scene.add( mesh );
			}
			
			createGrooveEdge( );
*/

			function newTile( )
			{
				const
					R = GROOVE_RADIUS,
					H = TILE_HEIGHT,
					U = 1;
			
				var shape = new THREE.Shape();
					shape.moveTo( A/2, 0 );
					shape.lineTo( R, 0 );
					shape.quadraticCurveTo( 0, 0, 0, R );
					shape.lineTo( 0, B-R );
					shape.quadraticCurveTo( 0, B, R/B*A, B-R );
					shape.lineTo( A, 0 );
				
				var geometry = new THREE.ExtrudeGeometry( shape, {
						steps: 1,
						depth: H,
						bevelEnabled: false });
						
				var material = new THREE.MeshPhysicalMaterial( {
					
						roughness: 0.2,
						metalness: 0,
						emissive: 'cornflowerblue',
						emissiveIntensity: 0.5,
						clearcoat: 1,
						sheen: new THREE.Color('crimson'),
						//map: frameTexture,
						//bumpMap: frameTexture,
						//bumpScale: 0.15,
						//wireframe: true,
						transmission: 0.9,
						thickness: 0,
						ior: 3,
						transparent: true,
						opacity: 1,
						//side: THREE.DoubleSide
						} );
						
				var plateMesh = new THREE.Mesh( geometry, material );
					plateMesh.rotation.x = -Math.PI/2;
					plateMesh.position.set( -A/K, 0, A/K );
					plateMesh.castShadow = true;
					//plateMesh.receiveShadow = true;
				
const edges = new THREE.EdgesGeometry( geometry, 90 );
const line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 'navy', transparent: true, opacity: 0.35 } ) );
plateMesh.add( line );

				var shape = new THREE.Shape();
					shape.moveTo( 0, 0 );
					shape.absarc( 0, 0, R, 0, 2*Math.PI );
				
				var geometry = new THREE.ExtrudeGeometry( shape, {
						steps: 1,
						depth: 2*U+H,
						bevelEnabled: false });
				
				var material = new THREE.MeshStandardMaterial( {
						roughness: 0,
						metalness: 0,
						emissive: 'gray',
						emissiveIntensity: 0.2,
						//map: frameTexture,
						//bumpMap: frameTexture,
						//bumpScale: 0.15,
						//wireframe: true,
						//side: THREE.DoubleSide
						//
						} );
						
				var bumpMesh = new THREE.Mesh( geometry, material );
					bumpMesh.rotation.x = -Math.PI/2;
					bumpMesh.position.set( 0, -U, 0 );
					bumpMesh.castShadow = true;
					bumpMesh.receiveShadow = true;

				var mesh = new THREE.Group();
				mesh.add( plateMesh, bumpMesh );
				scene.add( mesh );
				
				return mesh;
			}
			
			
			
			var pos = FRAME_WIDTH+A/K-FRAME_SIZE/2;
			
			var tile1 = newTile();
			tile1.position.set( pos, 0.1, -pos );
			
			var tile2 = newTile();
			tile2.position.set( -pos, 0.1, -pos );
			tile2.rotation.y = Math.PI/2;
			
			var tile3 = newTile();
			tile3.position.set( -pos, 0.1, pos );
			tile3.rotation.y = 2*Math.PI/2;
			
			var tile4 = newTile();
			tile4.position.set( pos, 0.1, pos );
			tile4.rotation.y = 3*Math.PI/2;
		
			
		</script>
		
	</body>
</html>


